{"instruction": "Write a Python function to calculate factorial", "input": "", "output": "def factorial(n):\n    \"\"\"Calculate the factorial of a non-negative integer.\n    \n    Args:\n        n (int): Non-negative integer\n        \n    Returns:\n        int: Factorial of n\n        \n    Raises:\n        ValueError: If n is negative\n        TypeError: If n is not an integer\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n    if n < 0:\n        raise ValueError(\"Input must be non-negative\")\n    \n    if n == 0 or n == 1:\n        return 1\n    \n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n    return result"}
{"instruction": "Create a Python class for a linked list node", "input": "", "output": "class ListNode:\n    \"\"\"A node in a singly linked list.\"\"\"\n    \n    def __init__(self, value=0, next=None):\n        \"\"\"Initialize a list node.\n        \n        Args:\n            value: The value to store in the node\n            next: Reference to the next node (default: None)\n        \"\"\"\n        self.value = value\n        self.next = next\n    \n    def __repr__(self):\n        \"\"\"String representation of the node.\"\"\"\n        return f\"ListNode({self.value})\"\n    \n    def __str__(self):\n        \"\"\"Human-readable string representation.\"\"\"\n        return str(self.value)"}
{"instruction": "Write a function to check if a string is a palindrome", "input": "", "output": "def is_palindrome(s: str) -> bool:\n    \"\"\"Check if a string is a palindrome.\n    \n    Args:\n        s: String to check\n        \n    Returns:\n        bool: True if palindrome, False otherwise\n    \"\"\"\n    # Remove non-alphanumeric characters and convert to lowercase\n    cleaned = ''.join(c.lower() for c in s if c.isalnum())\n    \n    # Compare with reversed string\n    return cleaned == cleaned[::-1]"}
{"instruction": "Implement a simple LRU cache in Python", "input": "", "output": "from collections import OrderedDict\n\nclass LRUCache:\n    \"\"\"Least Recently Used (LRU) cache implementation.\"\"\"\n    \n    def __init__(self, capacity: int):\n        \"\"\"Initialize LRU cache with given capacity.\n        \n        Args:\n            capacity: Maximum number of items in cache\n        \"\"\"\n        self.capacity = capacity\n        self.cache = OrderedDict()\n    \n    def get(self, key: int) -> int:\n        \"\"\"Get value for key from cache.\n        \n        Args:\n            key: Key to look up\n            \n        Returns:\n            Value if key exists, -1 otherwise\n        \"\"\"\n        if key not in self.cache:\n            return -1\n        \n        # Move to end to mark as recently used\n        self.cache.move_to_end(key)\n        return self.cache[key]\n    \n    def put(self, key: int, value: int) -> None:\n        \"\"\"Put key-value pair in cache.\n        \n        Args:\n            key: Key to store\n            value: Value to store\n        \"\"\"\n        if key in self.cache:\n            # Update existing key\n            self.cache.move_to_end(key)\n        \n        self.cache[key] = value\n        \n        # Remove least recently used if over capacity\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)"}
{"instruction": "Write a Python decorator for timing function execution", "input": "", "output": "import time\nimport functools\n\ndef timer(func):\n    \"\"\"Decorator to measure function execution time.\n    \n    Args:\n        func: Function to time\n        \n    Returns:\n        Wrapped function that prints execution time\n    \"\"\"\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        start_time = time.perf_counter()\n        \n        try:\n            result = func(*args, **kwargs)\n            return result\n        finally:\n            end_time = time.perf_counter()\n            elapsed = end_time - start_time\n            print(f\"{func.__name__} took {elapsed:.4f} seconds\")\n    \n    return wrapper"}
